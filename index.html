<!DOCTYPE html>

<html>
<head>
  <title>quick_check.coffee</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>quick_check.coffee</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>Welcome to quick_check.js. This program is written in CoffeeScript, but the
source is quite simple and shouldnâ€™t be too dificult to understand.</p>
<p>We start by defining our main function, <code>qc</code> which performs the actual checking
and also we use it to namespace all our other public functions. Functions without
the qc prefix are considered private to this library.</p>
<p>The qc function will generate 100 test cases and run the supplied property.
Based on the resulting value, we either succeed, fail or skip the test. Additionally
if a string is returned we classify the tests based on the returned string.</p>
<p>For failed cases we want to then make the example minimal in a process called
shrinking (more on this later on).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-title">qc</span> = <span class="hljs-params">(prop, generators...)</span> -&gt;</span>
  num = <span class="hljs-number">100</span>; skipped = <span class="hljs-number">0</span>; hist = {}
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0.</span>..num]
    examples = (generator(i) <span class="hljs-keyword">for</span> generator <span class="hljs-keyword">in</span> generators)
    result = prop(examples...)
    <span class="hljs-keyword">if</span> result == <span class="hljs-literal">false</span>
      <span class="hljs-keyword">if</span> qc._performShrinks
        minimal = findMinimalExample(prop, examples, generators)
        skippedString = <span class="hljs-keyword">if</span> skipped &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-string">" (<span class="hljs-subst">#{skipped}</span> skipped)"</span> <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attribute">pass</span>: <span class="hljs-literal">no</span>,
          <span class="hljs-attribute">examples</span>: examples,
          <span class="hljs-attribute">minimalExamples</span>: minimal.examples,
          <span class="hljs-attribute">message</span>: <span class="hljs-string">"Falsified after <span class="hljs-subst">#{i + <span class="hljs-number">1</span>}</span> attempt<span class="hljs-subst">#{<span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-string">''</span> <span class="hljs-keyword">else</span> <span class="hljs-string">'s'</span>}</span><span class="hljs-subst">#{skippedString}</span>. Counter-example (after <span class="hljs-subst">#{minimal.shrinkCount}</span> shrinks): <span class="hljs-subst">#{stringify(minimal.examples, generators)}</span>\n\nNon-shrunk counter-example: <span class="hljs-subst">#{stringify(examples, generators)}</span>"</span>
        }
      <span class="hljs-keyword">else</span>
        skippedString = <span class="hljs-keyword">if</span> skipped &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-string">" (<span class="hljs-subst">#{skipped}</span> skipped)"</span> <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attribute">pass</span>: <span class="hljs-literal">no</span>,
          <span class="hljs-attribute">examples</span>: examples,
          <span class="hljs-attribute">message</span>: <span class="hljs-string">"Falsified after <span class="hljs-subst">#{i + <span class="hljs-number">1</span>}</span> attempt<span class="hljs-subst">#{<span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-string">''</span> <span class="hljs-keyword">else</span> <span class="hljs-string">'s'</span>}</span><span class="hljs-subst">#{skippedString}</span>. Counter-example: <span class="hljs-subst">#{stringify(examples, generators)}</span>"</span>
        }
    <span class="hljs-keyword">if</span> result == <span class="hljs-literal">undefined</span>
      num++; skipped++
      <span class="hljs-keyword">if</span> skipped &gt; <span class="hljs-number">200</span>
        <span class="hljs-keyword">return</span> <span class="hljs-attribute">pass</span>: <span class="hljs-literal">no</span>, <span class="hljs-attribute">examples</span>: examples, <span class="hljs-attribute">message</span>: <span class="hljs-string">"Gave up after <span class="hljs-subst">#{i}</span> (<span class="hljs-subst">#{skipped}</span> skipped) attempts."</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">typeof</span> result <span class="hljs-keyword">is</span> <span class="hljs-string">'string'</span>
      hist[result] = <span class="hljs-keyword">if</span> hist[result]? <span class="hljs-keyword">then</span> hist[result] + <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>

  skippedString = <span class="hljs-keyword">if</span> skipped &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-string">" (<span class="hljs-subst">#{skipped}</span> skipped)"</span> <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>
  histString = makeHistogram hist, num

  <span class="hljs-keyword">return</span> <span class="hljs-attribute">pass</span>: <span class="hljs-literal">yes</span>, <span class="hljs-attribute">examples</span>: examples, <span class="hljs-attribute">message</span>: <span class="hljs-string">"Passed <span class="hljs-subst">#{num}</span> tests<span class="hljs-subst">#{skippedString}</span>.<span class="hljs-subst">#{histString}</span>"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>When an example fails, we need to convert it to a string to show the user the
failing test case. Currently if it is a function that failed, we call <code>toString</code>
on it, otherwise we turn it to JSON. This behavior should be more refined for
custom types.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-title">stringify</span> = <span class="hljs-params">(examples)</span> -&gt;</span>
  (<span class="hljs-keyword">if</span> <span class="hljs-keyword">typeof</span> example <span class="hljs-keyword">is</span> <span class="hljs-string">'function'</span> <span class="hljs-keyword">then</span> example.toString() <span class="hljs-keyword">else</span> JSON.stringify(example) <span class="hljs-keyword">for</span> example <span class="hljs-keyword">in</span> examples).join(<span class="hljs-string">', '</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>If the user uses categorization for their results, we want to print it out in a
sorted list with percentages of values that went there.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-title">makeHistogram</span> = <span class="hljs-params">(hist, total)</span> -&gt;</span>
  hist = ({label, count} <span class="hljs-keyword">for</span> label, count <span class="hljs-keyword">of</span> hist)
  hist.sort ({<span class="hljs-attribute">count</span>: a}, {<span class="hljs-attribute">count</span>: b}) -&gt; a - b
  <span class="hljs-string">"\n"</span> + hist.map(<span class="hljs-function"><span class="hljs-params">({label, count})</span> -&gt;</span> <span class="hljs-string">"<span class="hljs-subst">#{((count / total) * <span class="hljs-number">100</span>).toFixed(<span class="hljs-number">2</span>)}</span>% <span class="hljs-subst">#{label}</span>"</span>).join(<span class="hljs-string">"\n"</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p><code>qc.forAll</code> is a convenience method for executing quick checks, but the return values are
ignored. This is useful with seperate expectations:</p>
<pre><code>qc.forAll qc.int, <span class="hljs-function"><span class="hljs-params">(i)</span> -&gt;</span> expect(i + i).toBe(<span class="hljs-number">2</span> * i)
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>qc.forAll = <span class="hljs-function"><span class="hljs-params">(generators..., prop)</span> -&gt;</span>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0.</span>..<span class="hljs-number">100</span>]
    examples = (generator(i) <span class="hljs-keyword">for</span> generator <span class="hljs-keyword">in</span> generators)
    prop(examples...)</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>We make our own alias of the random function. When writing your own generators,
use of this is required, because some planned features in the future may require
use of a custom generator.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.random = Math.random</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>We make this globally available.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">if</span> @?
  <span class="hljs-property">@qc</span> = qc
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">window</span>?
  <span class="hljs-built_in">window</span>.qc = qc

<span class="hljs-built_in">module</span>.exports = qc <span class="hljs-keyword">if</span> <span class="hljs-built_in">module</span>?</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h1 id="generators">Generators</h1>
<p>This library bundle a number of simple generators that help for testing a lot of
common functionality but can also be used by composition in your custom generators.
Finally these generators can be used as examples how to write your own generators.</p>

            </div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>A generator is a function that accepts an optional <code>size</code> parameter and returns a random value.</p>

            </div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <h3 id="basic-generators">Basic generators</h3>

            </div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Generates a random boolean.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.bool = <span class="hljs-function"><span class="hljs-params">(size)</span> -&gt;</span> qc.choose(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Generates a random integer between 0 and 255.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.byte = <span class="hljs-function"><span class="hljs-params">(size)</span> -&gt;</span> Math.floor(qc.random() * <span class="hljs-number">256</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Generates random objects by calling the constructor with random arguments.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.constructor = <span class="hljs-function"><span class="hljs-params">(cons, arggens...)</span> -&gt;</span>
  (size) -&gt;
    args = (arggen(size - <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> arggen <span class="hljs-keyword">in</span> arggens)
    <span class="hljs-keyword">new</span> cons(args...)</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Generates a random value by calling a function with random arguments.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.fromFunction = <span class="hljs-function"><span class="hljs-params">(fun, arggens...)</span> -&gt;</span>
  (size) -&gt;
    args = (arggen(size - <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> arggen <span class="hljs-keyword">in</span> arggens)
    fun(args...)</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Return a function that randomly chooses one of the arguments passed to <code>qc.pick</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.pick =  <span class="hljs-function"><span class="hljs-params">(range...)</span> -&gt;</span>
  range = range[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> arguments.length ==  <span class="hljs-number">1</span>
  -&gt; range[Math.floor(qc.random() * range.length)]

qc.choose =  <span class="hljs-function"><span class="hljs-params">(range...)</span> -&gt;</span> qc.pick(range...)()</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <h3 id="generator-combinators">Generator combinators</h3>
<p>These combinator functions are meant to create new generators out of other generators.</p>

            </div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p><code>qc.oneOf</code> will choose between all the generators passed to it (accepts also an array of generators)
and generate a value from it. For example:</p>
<pre><code>stringOrNumber = qc.oneOf(qc.string, qc.real)
stringOrNumber(size) <span class="hljs-comment"># "frqw"</span>
stringOrNumber(size) <span class="hljs-comment"># 5.54</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>qc.oneOf =  <span class="hljs-function"><span class="hljs-params">(generators...)</span> -&gt;</span>
  (size) -&gt;
    qc.choose(generators...)(size)</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p><code>qc.oneOfByPriority</code> will choose a generator based on a distribution. This is
used for optimizing cases for simpler generators. See <code>qc.any</code> for an example.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.oneOfByPriority = <span class="hljs-function"><span class="hljs-params">(generators...)</span> -&gt;</span>
  (size) -&gt;
    gindex = Math.floor((<span class="hljs-number">1</span> - Math.sqrt(qc.random())) * generators.length)
    generators[gindex](size)</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p><code>qc.except</code> will run the generator passed to it as normal, but when it generates
one of the <code>values</code> passed to it, it will try the generator again to guarantee that
the generator will generate a value other then any of the values. So <code>qc.except(qc.uint, 0)(size)</code>
will generate a natural number, since <code>qc.uint</code> it will generate a random positive integer,
and if it generates 0, it will try again.</p>
<p>This is quite a naive implementation as it will simply try again if the generator
does generate one of the values. If the probability of generating one of these
values is high, this can really kill performace, so for those cases a custom
implementation might be better (e.g. the string generator does this).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.except =  <span class="hljs-function"><span class="hljs-params">(generator, values...)</span> -&gt;</span>
<span class="hljs-function">  <span class="hljs-title">anyMatches</span> = <span class="hljs-params">(expect)</span> -&gt;</span> <span class="hljs-keyword">return</span> (<span class="hljs-literal">true</span> <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> values <span class="hljs-keyword">when</span> v <span class="hljs-keyword">is</span> expect).length &gt; <span class="hljs-number">0</span>
  (size) -&gt;
    <span class="hljs-keyword">loop</span>
      value = generator(size)
      <span class="hljs-keyword">return</span> value <span class="hljs-keyword">unless</span> anyMatches value</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <h3 id="number-generators">Number generators</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function">
<span class="hljs-title">adjust</span> = <span class="hljs-params">(size)</span> -&gt;</span> <span class="hljs-keyword">if</span> size &lt; <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> Math.abs(size) + <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> size</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Almost all number generators have a large variant for generating larger numbers,
as the standard generators tend not to generate numbers bigger than 10,000. The
generators prefixed with <code>u</code> generate only positive numbers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.intUpto = <span class="hljs-function"><span class="hljs-params">(size)</span> -&gt;</span> Math.floor(qc.random() * adjust size)

qc.ureal = <span class="hljs-function"><span class="hljs-params">(size)</span> -&gt;</span> qc.random() * adjust(size * size)
qc.ureal.large = <span class="hljs-function"><span class="hljs-params">(size)</span> -&gt;</span> qc.random() * Number.MAX_VALUE

qc.real =  <span class="hljs-function"><span class="hljs-params">(size)</span> -&gt;</span> qc.choose(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>) * qc.ureal(size)
qc.real.large = <span class="hljs-function"><span class="hljs-params">(size)</span> -&gt;</span> qc.choose(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>) * qc.ureal.large()

qc.uint = <span class="hljs-function"><span class="hljs-params">(size)</span> -&gt;</span> qc.intUpto(adjust size * size)
qc.uint.large = <span class="hljs-function"><span class="hljs-params">(size)</span> -&gt;</span> Math.floor(qc.random() * Number.MAX_VALUE)

qc.int = <span class="hljs-function"><span class="hljs-params">(size)</span> -&gt;</span> qc.choose(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>) * qc.intUpto(adjust size * size)
qc.int.large = <span class="hljs-function"><span class="hljs-params">(size)</span> -&gt;</span> qc.choose(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>) * qc.uint.large()
qc.int.between = <span class="hljs-function"><span class="hljs-params">(min, max)</span> -&gt;</span>
  (size) -&gt;
    min + qc.intUpto(Math.min(max + <span class="hljs-number">1</span> - min, adjust size))

qc.natural = <span class="hljs-function"><span class="hljs-params">(size)</span> -&gt;</span> qc.intUpto(adjust size * size) + <span class="hljs-number">1</span>
qc.natural.large = <span class="hljs-function"><span class="hljs-params">(size)</span> -&gt;</span> Math.ceil(qc.random() * Number.MAX_VALUE)</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Range generators will generate an array of two numbers where the second is
guaranteed to be larger than the first. i.e.</p>
<pre><code>expect(<span class="hljs-function"><span class="hljs-params">([min, max])</span> -&gt;</span> min &lt; max).forAll(qc.range())
expect(<span class="hljs-function"><span class="hljs-params">([min, max])</span> -&gt;</span> min &lt;= max).forAll(qc.range.inclusive(qc.real))
expect(<span class="hljs-function"><span class="hljs-params">([min, max])</span> -&gt;</span> <span class="hljs-number">0</span> &lt;= min &lt; max).forAll(qc.range(qc.ureal))
expect(<span class="hljs-function"><span class="hljs-params">([min, max])</span> -&gt;</span> <span class="hljs-number">0</span> &lt; min &lt; max).forAll(qc.range(qc.natural))
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>qc.range = <span class="hljs-function"><span class="hljs-params">(gen = qc.real)</span> -&gt;</span>
  (size) -&gt;
    start = gen(size)
    end = start + Math.abs(gen(size))
    end += <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> start <span class="hljs-keyword">is</span> end
    [start, end]

qc.range.inclusive = <span class="hljs-function"><span class="hljs-params">(gen = qc.real)</span> -&gt;</span>
  (size) -&gt;
    start = gen(size)
    [start, start + Math.abs(gen(size))]</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>The dice generator takes a D&amp;D style dice string and transforms it into a random
number generator. This can serve as a very quick method how to quickly approximate
distributions.</p>
<pre><code>qc.dice(<span class="hljs-string">'d3'</span>) == <span class="hljs-function">-&gt;</span> Math.ceil(qc.random() * <span class="hljs-number">3</span>)
qc.dice(<span class="hljs-string">'d2 + d4 + 3'</span>) == <span class="hljs-function">-&gt;</span>
  Math.ceil(qc.random() * <span class="hljs-number">2</span>) + Math.ceil(qc.random() * <span class="hljs-number">4</span>) + <span class="hljs-number">3</span>
qc.dice(<span class="hljs-string">'2d6'</span>) == <span class="hljs-function">-&gt;</span>
  Math.ceil(qc.random() * <span class="hljs-number">6</span>) + Math.ceil(qc.random() * <span class="hljs-number">6</span>)
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>qc.dice = <span class="hljs-function"><span class="hljs-params">(config)</span> -&gt;</span>
  toks = config.trim()
  code = <span class="hljs-string">''</span>
  isConditional = <span class="hljs-literal">no</span>
  declaration = <span class="hljs-literal">no</span>
<span class="hljs-function">  <span class="hljs-title">consume</span> = <span class="hljs-params">(n)</span> -&gt;</span> toks = toks.substring(n)
  <span class="hljs-keyword">while</span> toks.length &gt; <span class="hljs-number">0</span>
    token = toks[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">switch</span>
      <span class="hljs-keyword">when</span> token <span class="hljs-keyword">is</span> <span class="hljs-string">'+'</span> <span class="hljs-keyword">then</span> code += <span class="hljs-string">' + '</span>
      <span class="hljs-keyword">when</span> token <span class="hljs-keyword">is</span> <span class="hljs-string">'-'</span> <span class="hljs-keyword">then</span> code += <span class="hljs-string">' - '</span>
      <span class="hljs-keyword">when</span> token <span class="hljs-keyword">is</span> <span class="hljs-string">'*'</span> <span class="hljs-keyword">then</span> code += <span class="hljs-string">' * '</span>
      <span class="hljs-keyword">when</span> token <span class="hljs-keyword">is</span> <span class="hljs-string">'/'</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">'Division is currently not supported'</span>
      <span class="hljs-keyword">when</span> token <span class="hljs-keyword">is</span> <span class="hljs-string">' '</span> <span class="hljs-keyword">then</span> code
      <span class="hljs-keyword">when</span> token <span class="hljs-keyword">is</span> <span class="hljs-string">'('</span> <span class="hljs-keyword">then</span> code += <span class="hljs-string">'('</span>
      <span class="hljs-keyword">when</span> token <span class="hljs-keyword">is</span> <span class="hljs-string">')'</span> <span class="hljs-keyword">then</span> code += <span class="hljs-string">')'</span>
      <span class="hljs-keyword">when</span> token <span class="hljs-keyword">is</span> <span class="hljs-string">'?'</span>
        isConditional = <span class="hljs-literal">yes</span>
        code += <span class="hljs-string">' &gt; 0 ? '</span>
      <span class="hljs-keyword">when</span> token <span class="hljs-keyword">is</span> <span class="hljs-string">':'</span> <span class="hljs-keyword">and</span> isConditional
        isConditional = <span class="hljs-literal">no</span>
        code += <span class="hljs-string">' : '</span>
      <span class="hljs-keyword">when</span> match = toks.match(<span class="hljs-regexp">/^(\d*)d(\d+)/</span>)
        num = parseInt(match[<span class="hljs-number">1</span>], <span class="hljs-number">10</span>) <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>
        max = parseInt match[<span class="hljs-number">2</span>], <span class="hljs-number">10</span>
        consume match[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> num &lt; <span class="hljs-number">5</span>
          code += <span class="hljs-string">'('</span> + (<span class="hljs-string">"Math.ceil(qc.random() * <span class="hljs-subst">#{max}</span>)"</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1.</span>.num]).join(<span class="hljs-string">' + '</span>) + <span class="hljs-string">')'</span>
        <span class="hljs-keyword">else</span> <span class="hljs-comment"># we do not want to inline this loop</span>
          declaration = <span class="hljs-literal">yes</span>
          code += <span class="hljs-string">"d(<span class="hljs-subst">#{num}</span>, <span class="hljs-subst">#{max}</span>)"</span>
      <span class="hljs-keyword">when</span> match = toks.match(<span class="hljs-regexp">/^(\d*)F/</span>)
        num = parseInt(match[<span class="hljs-number">1</span>], <span class="hljs-number">10</span>) <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>
        consume match[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>
        code += <span class="hljs-string">"(qc.random() &lt;= <span class="hljs-subst">#{Math.pow(<span class="hljs-number">0.5</span>, num)}</span> ? 1 : 0)"</span>
      <span class="hljs-keyword">when</span> match = toks.match(<span class="hljs-regexp">/^\d+/</span>)
        num = parseInt(match[<span class="hljs-number">0</span>], <span class="hljs-number">10</span>)
        consume match[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>
        code += num
      <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">"Unexpected token '<span class="hljs-subst">#{token}</span>'."</span>
    consume <span class="hljs-number">1</span>
  <span class="hljs-keyword">if</span> declaration
    <span class="hljs-keyword">new</span> Function <span class="hljs-string">"""
      function d(num, max) {
        var sum = 0;
        for (var i = 0; i &lt; num; i++) {
          sum += Math.ceil(qc.random() * max);
        }
        return sum;
      }

      return <span class="hljs-subst">#{code}</span>;
    """</span>
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">new</span> Function <span class="hljs-string">"return <span class="hljs-subst">#{code}</span>;"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <h3 id="array-generators">Array generators</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-title">normalizeOptions</span> = <span class="hljs-params">(options = {})</span> -&gt;</span>
  <span class="hljs-attribute">length</span>: <span class="hljs-keyword">if</span> options.length?
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">typeof</span> options.length <span class="hljs-keyword">is</span> <span class="hljs-string">'function'</span>
      options.length
    <span class="hljs-keyword">else</span>
      -&gt; options.length
  <span class="hljs-keyword">else</span>
    qc.intUpto
  <span class="hljs-attribute">sparse</span>: options.sparse ? <span class="hljs-literal">false</span></pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>This function randomly removes elements from an array so that it will turn sparse.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-title">sparsify</span> = <span class="hljs-params">(arr, {sparse})</span> -&gt;</span>
  <span class="hljs-keyword">if</span> sparse
    arr = arr.slice()
    <span class="hljs-keyword">delete</span> arr[i] <span class="hljs-keyword">for</span> el, i <span class="hljs-keyword">in</span> arr <span class="hljs-keyword">when</span> qc.random() &gt; <span class="hljs-number">0.6</span>
    arr
  <span class="hljs-keyword">else</span>
    arr</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p><code>qc.arrayOf(generator, options={})</code> will return a random generator, which will generate
an array from that generator.</p>
<p>options can have (currently) the following keys:
<code>length</code>: should be a generator (or a constant number) that specifies how many elements
should the array have.
<code>sparse</code>: a boolean, which controls if the array can be sparse.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.arrayOf =  <span class="hljs-function"><span class="hljs-params">(generator, options = {})</span> -&gt;</span>
  options = normalizeOptions(options)
  (size) -&gt;
    sparsify(generator(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0.</span>..options.length(size)], options)</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p><code>qc.array</code> will generate a random array of any type.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.array = <span class="hljs-function"><span class="hljs-params">(size)</span> -&gt;</span> qc.arrayOf(qc.any)(<span class="hljs-keyword">if</span> size &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> size - <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p><code>qc.array.subsetOf(array, options)</code> will return a random generator that will generate
a subset of an array.</p>
<p>For example <code>qc.array.subsetOf([1,2,3,4])(size)</code> could yield <code>[3, 1]</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.array.subsetOf = <span class="hljs-function"><span class="hljs-params">(array, options = {})</span> -&gt;</span>
  options.length ?= qc.intUpto array.length + <span class="hljs-number">1</span>
  options = normalizeOptions(options)
  (size) -&gt;
    copy = array.slice()
    sparsify(copy.splice(qc.intUpto(copy.length), <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0.</span>..options.length(size)], options)</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <h3 id="function-generators">Function generators</h3>

            </div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Generating a function has several limitations. Firstly we will only want to
generate pure functions. A pure function can take a number of arguments and returns
a value. Such a function is fundamentally a lookup table where the return value
can be found through the arguments. In general the problem is that for some (most)
functions the table is infinite. However any program that actually runs will only
ever explore a finite portion of this table. So for a particular run of a program,
and for a function f that we can represent with the infinite table x, we can
find a finite table xâ€™ that will fully simulate the behavior of the function f.</p>
<p>We exploit this fact in quick check. Our function generator creates an empty table,
and then returns a function which will lookup the arguments passed to it. If the
arguments are present in the table, the return value is returned. Otherwise a
random value is generated and stored with the arguments in the table.</p>
<p>Finally we override the toString method of the returned function to emit human
readable source code.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.<span class="hljs-reserved">function</span> =  <span class="hljs-function"><span class="hljs-params">(args..., returnGenerator)</span> -&gt;</span>
<span class="hljs-function">  <span class="hljs-title">generator</span> = <span class="hljs-params">(size)</span> -&gt;</span>
    generator.calls = []
<span class="hljs-function">    <span class="hljs-title">result</span> = <span class="hljs-params">(someArgs...)</span> -&gt;</span>
      <span class="hljs-keyword">return</span> value <span class="hljs-keyword">for</span> [callArgs..., value] <span class="hljs-keyword">in</span> generator.calls <span class="hljs-keyword">when</span> arraysEqual(callArgs, someArgs)
      value = returnGenerator(size)
      generator.calls.push([someArgs..., value])
      <span class="hljs-keyword">return</span> value
    result.toString = <span class="hljs-function">-&gt;</span>
      calls = generator.calls
      <span class="hljs-keyword">if</span> calls.length == <span class="hljs-number">0</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"function() { return <span class="hljs-subst">#{JSON.stringify returnGenerator(<span class="hljs-number">10</span>)}</span>; }"</span>
      argNames = (String.fromCharCode(i + <span class="hljs-number">97</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0.</span>..calls[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>])
      clauses = <span class="hljs-keyword">for</span> [args..., value], pos <span class="hljs-keyword">in</span> calls
        condition = (<span class="hljs-string">"<span class="hljs-subst">#{argNames[i]}</span> === <span class="hljs-subst">#{JSON.stringify arg}</span>"</span> <span class="hljs-keyword">for</span> arg, i <span class="hljs-keyword">in</span> args).join(<span class="hljs-string">' &amp;&amp; '</span>)
        <span class="hljs-keyword">if</span> calls.length == <span class="hljs-number">1</span>
          <span class="hljs-string">"return <span class="hljs-subst">#{JSON.stringify value}</span>;"</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> pos == calls.length - <span class="hljs-number">1</span>
          <span class="hljs-string">"{\n    return <span class="hljs-subst">#{JSON.stringify value}</span>;\n  }"</span>
        <span class="hljs-keyword">else</span>
          <span class="hljs-string">"if (<span class="hljs-subst">#{condition}</span>) {\n    return <span class="hljs-subst">#{JSON.stringify value}</span>;\n  }"</span>
      <span class="hljs-string">"""

      function(<span class="hljs-subst">#{argNames.join(<span class="hljs-string">", "</span>)}</span>) {
        <span class="hljs-subst">#{clauses.join(<span class="hljs-string">" else "</span>)}</span>
      }
      """</span>
    result
  generator</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>This alias is for languages that donâ€™t like the reserved word as an identifier.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.pureFunction = qc.<span class="hljs-reserved">function</span></pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>To lookup things in the table we need a notion of equality. QuickCheck currently
supports only equality testing with <code>===</code>, however in future versions we will
hopefully lift this limitation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-title">arraysEqual</span> = <span class="hljs-params">(a1, a2)</span> -&gt;</span>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-keyword">if</span> a1.length != a2.length
  <span class="hljs-keyword">for</span> arg, i <span class="hljs-keyword">in</span> a1
    <span class="hljs-keyword">if</span> arg != a2[i]
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>A procedure is a function composed of discrete operations that has side effects.</p>
<p>As an example, we give a procedure to draw a random image into the canvas</p>
<pre><code>canvas = qc.procedure <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Canvas</span></span>
  <span class="hljs-comment"># Constructor gets called only once</span>
  <span class="hljs-attribute">constructor</span>: <span class="hljs-function"><span class="hljs-params">($args)</span> -&gt;</span>
    <span class="hljs-property">@canvas</span> = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'canvas'</span>)
    <span class="hljs-property">@canvas</span>.width = <span class="hljs-property">@width</span> = $args[<span class="hljs-number">0</span>]
    <span class="hljs-property">@canvas</span>.height = <span class="hljs-property">@height</span> = $args[<span class="hljs-number">1</span>]
    <span class="hljs-property">@ctx</span> = canvas.getContext(<span class="hljs-string">'2d'</span>)
  <span class="hljs-comment"># A function can have basic types injected</span>
  <span class="hljs-attribute">lineTo</span>: <span class="hljs-function"><span class="hljs-params">(uint1, uint2)</span> -&gt;</span>
    <span class="hljs-property">@ctx</span>.lineTo Math.max(uint1, <span class="hljs-property">@width</span>), Math.max(uint2, <span class="hljs-property">@height</span>)
  <span class="hljs-comment"># A $final method will only be called once and its return value</span>
  <span class="hljs-comment"># will be the return value of the procedure.</span>
  <span class="hljs-attribute">$final</span>: <span class="hljs-function">-&gt;</span>
    <span class="hljs-property">@canvas</span>.toDataURL()

expect (drawCanvas) -&gt;
  isValidPng(drawCanvas(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>))
.forAll canvas
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>qc.procedure = <span class="hljs-function"><span class="hljs-params">(obj, injectorConfig = {})</span> -&gt;</span>
  FN_ARGS = <span class="hljs-regexp">/^function\s*[^\(]*\(\s*([^\)]*)\)/m</span>;
  FN_ARG_SPLIT = <span class="hljs-regexp">/,/</span>
  FN_ARG = <span class="hljs-regexp">/^\s*(\S+?)\s*$/</span>
  STRIP_COMMENTS = <span class="hljs-regexp">/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg</span>
<span class="hljs-function">  <span class="hljs-title">extractArgs</span> = <span class="hljs-params">(fn)</span> -&gt;</span>
    args = fn.toString().replace(STRIP_COMMENTS, <span class="hljs-string">''</span>).match(FN_ARGS)
    <span class="hljs-keyword">if</span> args
      argName.match(FN_ARG)[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> argName <span class="hljs-keyword">in</span> args[<span class="hljs-number">1</span>].split(FN_ARG_SPLIT) <span class="hljs-keyword">when</span> argName <span class="hljs-keyword">isnt</span> <span class="hljs-string">''</span>
<span class="hljs-function">
  <span class="hljs-title">fnKeys</span> = <span class="hljs-params">(obj)</span> -&gt;</span> key <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">of</span> obj <span class="hljs-keyword">when</span> key <span class="hljs-keyword">isnt</span> <span class="hljs-string">'$final'</span> <span class="hljs-keyword">and</span> (<span class="hljs-keyword">typeof</span> val <span class="hljs-keyword">is</span> <span class="hljs-string">'function'</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">typeof</span> val <span class="hljs-keyword">is</span> <span class="hljs-string">'object'</span> <span class="hljs-keyword">and</span> val.length <span class="hljs-keyword">and</span> <span class="hljs-keyword">typeof</span> val[val.length - <span class="hljs-number">1</span>] <span class="hljs-keyword">is</span> <span class="hljs-string">'function'</span>)
<span class="hljs-function">
  <span class="hljs-title">getGenerators</span> = <span class="hljs-params">(injector, obj, prefix)</span> -&gt;</span>
    <span class="hljs-keyword">for</span> own key, fn <span class="hljs-keyword">of</span> obj
      <span class="hljs-keyword">if</span> <span class="hljs-keyword">typeof</span> fn <span class="hljs-keyword">is</span> <span class="hljs-string">'function'</span> <span class="hljs-keyword">and</span> fn.length <span class="hljs-keyword">is</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> extractArgs(fn)[<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-string">'size'</span>
        injector[prefix + key] = fn
      getGenerators injector, fn, prefix + key + <span class="hljs-string">'_'</span>
    <span class="hljs-keyword">return</span>
<span class="hljs-function">
  <span class="hljs-title">initializeInjector</span> = <span class="hljs-params">(injectorConfig)</span> -&gt;</span>
    injector = {}
    getGenerators injector, qc, <span class="hljs-string">''</span>
    injector[key] = val <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">of</span> injectorConfig
    injector

  (size) -&gt;
    injector = initializeInjector(injectorConfig)
<span class="hljs-function">    <span class="hljs-title">invoke</span> = <span class="hljs-params">(key, args, obj, result)</span> -&gt;</span>
      injectors = []
      injector.$args = <span class="hljs-function">-&gt;</span> args
<span class="hljs-function">      <span class="hljs-title">fn</span> = -&gt;</span>
      <span class="hljs-keyword">if</span> <span class="hljs-keyword">typeof</span> obj[key] <span class="hljs-keyword">is</span> <span class="hljs-string">'function'</span>
        fn = obj[key]
        <span class="hljs-keyword">if</span> obj[key].$inject?
          injectors = obj[key].$inject?
        <span class="hljs-keyword">else</span>
          injectors = (injector[name.replace(<span class="hljs-regexp">/\d+$/</span>, <span class="hljs-string">''</span>)] <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> extractArgs(obj[key]))
      <span class="hljs-keyword">else</span>
        fn = obj[key][obj[key].length - <span class="hljs-number">1</span>]
        injectors = obj[key].slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)
      fnarguments = (gen(size) <span class="hljs-keyword">for</span> gen <span class="hljs-keyword">in</span> injectors)
      result.trace.push({key, <span class="hljs-attribute">args</span>: fnarguments})
      fn.apply(obj, fnarguments)
<span class="hljs-function">
    <span class="hljs-title">result</span> = <span class="hljs-params">(args...)</span> -&gt;</span>
      result.trace = []
      result.classMode = <span class="hljs-keyword">typeof</span> obj <span class="hljs-keyword">is</span> <span class="hljs-string">'function'</span>
      callee = <span class="hljs-keyword">if</span> <span class="hljs-keyword">typeof</span> obj <span class="hljs-keyword">is</span> <span class="hljs-string">'function'</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">new</span> obj(args) <span class="hljs-keyword">else</span> obj
      steps = fnKeys callee
      execution = qc.arrayOf(qc.pick steps)(size)
      invoke(key, args, callee, result) <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> execution
      <span class="hljs-keyword">if</span> callee.$final <span class="hljs-keyword">then</span> invoke(<span class="hljs-string">'$final'</span>, args, callee, result) <span class="hljs-keyword">else</span> <span class="hljs-literal">undefined</span>

    result.toString = <span class="hljs-function">-&gt;</span>
      code = []
      name = obj.name || injector.name || <span class="hljs-string">'Api'</span>
      <span class="hljs-keyword">if</span> result.classMode
        code.push <span class="hljs-string">"var obj = new <span class="hljs-subst">#{name}</span>(arguments);"</span>
        name = <span class="hljs-string">'obj'</span>
      <span class="hljs-keyword">for</span> {key, args} <span class="hljs-keyword">in</span> result.trace
        ret = <span class="hljs-keyword">if</span> key <span class="hljs-keyword">is</span> <span class="hljs-string">'$final'</span> <span class="hljs-keyword">then</span> <span class="hljs-string">'return '</span> <span class="hljs-keyword">else</span> <span class="hljs-string">''</span>
        code.push <span class="hljs-string">"<span class="hljs-subst">#{ret}</span><span class="hljs-subst">#{name}</span>.<span class="hljs-subst">#{key}</span>(<span class="hljs-subst">#{(JSON.stringify(arg) <span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> args).join(<span class="hljs-string">', '</span>)}</span>);"</span>

      <span class="hljs-string">"function() {\n  <span class="hljs-subst">#{code.join(<span class="hljs-string">'\n  '</span>)}</span>\n}"</span>
    result</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <h3 id="object-generators">Object generators</h3>

            </div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p><code>qc.objectLike</code> accepts a template of an object with random generators as values,
and returns a generator of that form of object.</p>
<pre><code>qc.objectLike({
  <span class="hljs-attribute">hello</span>: <span class="hljs-string">"world"</span>,
  <span class="hljs-attribute">name</span>: qc.string.matching(<span class="hljs-regexp">/^m(r|s)\. [A-Z][a-z]{3,9}$/</span>)
})(size) <span class="hljs-regexp">//</span> <span class="hljs-attribute">generates</span>:
{
  <span class="hljs-attribute">hello</span>: <span class="hljs-string">"world"</span>,
  <span class="hljs-attribute">name</span>: <span class="hljs-string">"mr. Dasde"</span>
}
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>qc.objectLike = <span class="hljs-function"><span class="hljs-params">(template)</span> -&gt;</span>
  (size) -&gt;
    result = {}
    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">of</span> template
      <span class="hljs-keyword">if</span> <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'function'</span>
        result[key] = value(size)
      <span class="hljs-keyword">else</span>
        result[key] = value
    result</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p><code>qc.objectOf</code> generates an object containing the passed type as its values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.objectOf =  <span class="hljs-function"><span class="hljs-params">(generator, keygen = qc.string)</span> -&gt;</span>
  (size) -&gt;
    result = {}
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0.</span>.qc.intUpto(size)]
      result[keygen(size)] = generator(i)
    result</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p><code>qc.object</code> generates an object containing random types</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.object = <span class="hljs-function"><span class="hljs-params">(size)</span> -&gt;</span> qc.objectOf(qc.any)(size)</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <h3 id="string-generators">String generators</h3>

            </div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p><code>qc.char</code> will return a random string with a single chararcter.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.char = <span class="hljs-function"><span class="hljs-params">(size)</span> -&gt;</span> String.fromCharCode(qc.byte())</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p><code>qc.string</code> will generate a string of random charachters.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.string = <span class="hljs-function"><span class="hljs-params">(size)</span> -&gt;</span>
  s = <span class="hljs-string">""</span>
  s += qc.char() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0.</span>.qc.intUpto(size)]
  s</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p><code>qc.string.ascii</code> will generate a string of random ascii charachters.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.string.ascii = <span class="hljs-function"><span class="hljs-params">(size)</span> -&gt;</span>
  gen = qc.pick(makeRange(<span class="hljs-string">'a'</span>, <span class="hljs-string">'z'</span>, <span class="hljs-literal">true</span>).concat(makeRange(<span class="hljs-string">'0'</span>, <span class="hljs-string">'9'</span>)).concat([<span class="hljs-string">'_'</span>, <span class="hljs-string">' '</span>, <span class="hljs-string">'\n'</span>]))
  qc.arrayOf(gen)(size).join(<span class="hljs-string">''</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p><code>qc.string.concat</code> is a generator combinator (see above) that will generate all
the generators passed to it and then concatenate them into a single string.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.string.concat = <span class="hljs-function"><span class="hljs-params">(gens)</span> -&gt;</span>
  (size) -&gt; (gen(size) <span class="hljs-keyword">for</span> gen <span class="hljs-keyword">in</span> gens).join(<span class="hljs-string">''</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p><code>qc.string.matching(regexp)</code> will generate a random string matching a regular
expression. In order to do that the regular expression must be parsed and compiled
into a generator function. This is an example of a very non-trivial generator.</p>
<p>We make use of a number of smaller generators and generator combinators. Some of
them, which are of general use are exposed publicly above.</p>
<p>In regular expressions the basic elements are:</p>
<ul>
<li>literals, which translate to themselves (or to their uppercase variants)</li>
<li>dots, which can stand for anything</li>
<li>repeaters of various kinds (these are combinators that generate another generator
a set amount of times and concat the results)</li>
<li>ranges of characters (we can use the <code>qc.pick</code> generator to make these). We
have two helper functions, one for the <code>/[a-z]/</code> style ranges, the other for
negated ranges <code>/[^b]/</code>.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>generator =
  <span class="hljs-attribute">literal</span>: <span class="hljs-function"><span class="hljs-params">(lit, caseInsensitive)</span> -&gt;</span>
    <span class="hljs-keyword">if</span> caseInsensitive
     -&gt; qc.choose(lit.toLowerCase(), lit.toUpperCase())
    <span class="hljs-keyword">else</span>
     -&gt; lit
  <span class="hljs-attribute">dot</span>: qc.except(qc.char, <span class="hljs-string">'\n'</span>)
  <span class="hljs-attribute">repeat</span>: <span class="hljs-function"><span class="hljs-params">(gen, min, max)</span> -&gt;</span>
    (size) -&gt;
      (gen(size) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0.</span>..qc.int.between(min, max)(size)]).join(<span class="hljs-string">''</span>)
<span class="hljs-function">
<span class="hljs-title">makeRange</span> = <span class="hljs-params">(from, to, caseInsensitive)</span> -&gt;</span>
  <span class="hljs-keyword">if</span> caseInsensitive
    lowerCase = (String.fromCharCode(charCode) <span class="hljs-keyword">for</span> charCode <span class="hljs-keyword">in</span> [from.toLowerCase().charCodeAt(<span class="hljs-number">0</span>)..to.toLowerCase().charCodeAt(<span class="hljs-number">0</span>)])
    upperCase = (String.fromCharCode(charCode) <span class="hljs-keyword">for</span> charCode <span class="hljs-keyword">in</span> [from.toUpperCase().charCodeAt(<span class="hljs-number">0</span>)..to.toUpperCase().charCodeAt(<span class="hljs-number">0</span>)])
    lowerCase.concat(upperCase)
  <span class="hljs-keyword">else</span>
    String.fromCharCode(charCode) <span class="hljs-keyword">for</span> charCode <span class="hljs-keyword">in</span> [from.charCodeAt(<span class="hljs-number">0</span>)..to.charCodeAt(<span class="hljs-number">0</span>)]
<span class="hljs-function">
<span class="hljs-title">makeComplimentaryRange</span> = <span class="hljs-params">(range)</span> -&gt;</span>
  String.fromCharCode(char) <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> [<span class="hljs-number">0.</span>.<span class="hljs-number">256</span>] <span class="hljs-keyword">when</span> <span class="hljs-keyword">not</span> (String.fromCharCode(char) <span class="hljs-keyword">in</span> range)</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>Captures in our context are mostly useful for regexps where the use of backrefs
is made. <code>/^([a-z]) = (\d) * \(\1 \/ \2\)$</code> will result in a meaningful string like
<code>c = 21 * (c / 21)</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-title">capture</span> = <span class="hljs-params">(gen, captures, captureLevel)</span> -&gt;</span>
  (size) -&gt;
    value = gen(size)
    captures[captureLevel.toString()] ?= []
    captures[captureLevel.toString()].push(value)
    value</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>We need some special behavior for characters following the <code>\</code>. This function
provides that.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-title">handleClass</span> = <span class="hljs-params">(token, captures, captureLevel)</span> -&gt;</span>
  <span class="hljs-keyword">switch</span> token
    <span class="hljs-keyword">when</span> <span class="hljs-string">'w'</span>
      makeRange(<span class="hljs-string">'a'</span>, <span class="hljs-string">'z'</span>, <span class="hljs-literal">true</span>).concat(makeRange(<span class="hljs-string">'0'</span>, <span class="hljs-string">'9'</span>)).concat([<span class="hljs-string">'_'</span>])
    <span class="hljs-keyword">when</span> <span class="hljs-string">'W'</span>
      makeComplimentaryRange(makeRange(<span class="hljs-string">'a'</span>, <span class="hljs-string">'z'</span>, <span class="hljs-literal">true</span>).concat(makeRange(<span class="hljs-string">'0'</span>, <span class="hljs-string">'9'</span>)).concat([<span class="hljs-string">'_'</span>]))
    <span class="hljs-keyword">when</span> <span class="hljs-string">'d'</span>
      makeRange(<span class="hljs-string">'0'</span>, <span class="hljs-string">'9'</span>)
    <span class="hljs-keyword">when</span> <span class="hljs-string">'D'</span>
      makeComplimentaryRange(makeRange(<span class="hljs-string">'0'</span>, <span class="hljs-string">'9'</span>))
    <span class="hljs-keyword">when</span> <span class="hljs-string">'s'</span>
      [<span class="hljs-string">' '</span>, <span class="hljs-string">'\f'</span>, <span class="hljs-string">'\n'</span>, <span class="hljs-string">'\r'</span>, <span class="hljs-string">'\t'</span>, <span class="hljs-string">'\v'</span>]
    <span class="hljs-keyword">when</span> <span class="hljs-string">'S'</span>
      makeComplimentaryRange([<span class="hljs-string">' '</span>, <span class="hljs-string">'\f'</span>, <span class="hljs-string">'\n'</span>, <span class="hljs-string">'\r'</span>, <span class="hljs-string">'\t'</span>, <span class="hljs-string">'\v'</span>])
    <span class="hljs-keyword">when</span> <span class="hljs-string">'n'</span>
      [<span class="hljs-string">"\n"</span>]
    <span class="hljs-keyword">when</span> <span class="hljs-string">'t'</span>
      [<span class="hljs-string">"\t"</span>]
    <span class="hljs-keyword">when</span> <span class="hljs-string">'v'</span>
      [<span class="hljs-string">"\v"</span>]
    <span class="hljs-keyword">when</span> <span class="hljs-string">'b'</span>
      [<span class="hljs-string">'\b'</span>]
    <span class="hljs-keyword">when</span> <span class="hljs-string">'f'</span>
      [<span class="hljs-string">'\f'</span>]
    <span class="hljs-keyword">when</span> <span class="hljs-string">'r'</span>
      [<span class="hljs-string">'\r'</span>]
    <span class="hljs-keyword">when</span> <span class="hljs-string">'c'</span>
      <span class="hljs-keyword">throw</span> <span class="hljs-string">'Control sequences not supported'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>Captures are stored in a fairly complex data structure. The reason is that
members of the data structure often need to be accessed before their parents
are finished parsing. So we cannot use a simple array. For example consider
the case of <code>/((a)\2)/</code>. Here <code>\2</code> is requested before <code>\1</code> is done being parsed.</p>
<p>Therefore we store it in a hash where the recursive depth is the key, and the
value is an array of all captures on that level.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">when</span> <span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'6'</span>, <span class="hljs-string">'7'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'9'</span>
      <span class="hljs-keyword">if</span> captures
        index = parseInt(token, <span class="hljs-number">10</span>)
        -&gt;
          offset = <span class="hljs-number">0</span>
          <span class="hljs-keyword">for</span> level <span class="hljs-keyword">in</span> [<span class="hljs-number">0.</span>.<span class="hljs-number">9</span>]
            <span class="hljs-keyword">if</span> captures[level.toString()]?
              <span class="hljs-keyword">if</span> index - offset &lt; captures[level.toString()].length
                <span class="hljs-keyword">return</span> captures[level.toString()][index - offset]
              <span class="hljs-keyword">else</span>
                offset += captures[level.toString()].length
            <span class="hljs-keyword">else</span>
              offset += <span class="hljs-number">1</span>
    <span class="hljs-keyword">else</span>
      [token]</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>Now that we have all the basic elements in place we can do the actual parsing.
This is done recursively for all groups (e.g. anything wrapped with parentheses).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-title">generatorForPattern</span> = <span class="hljs-params">(toks, caseInsensitive, captures, captureLevel)</span> -&gt;</span>
  gens = []
  <span class="hljs-keyword">while</span> toks.length &gt; <span class="hljs-number">0</span>
    token = toks.shift()
    <span class="hljs-keyword">if</span> token.match(<span class="hljs-regexp">/[\w\s=]/i</span>)
      gens.push(generator.literal(token, caseInsensitive))
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> token <span class="hljs-keyword">is</span> <span class="hljs-string">'^'</span>
      captures.isHookedFromStart = <span class="hljs-literal">yes</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> token <span class="hljs-keyword">is</span> <span class="hljs-string">'$'</span>
      captures.isHookedFromEnd = <span class="hljs-literal">yes</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> token <span class="hljs-keyword">is</span> <span class="hljs-string">'.'</span>
      gens.push(generator.dot)
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> token <span class="hljs-keyword">is</span> <span class="hljs-string">'*'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>We implement lazy repeaters as generating shorter strings on average.
This is not really correct, as a lazy repeater should guarentee that
the string generated does not include whatâ€™s after.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> toks[<span class="hljs-number">0</span>] == <span class="hljs-string">'?'</span>
        <span class="hljs-built_in">console</span>.log <span class="hljs-string">"Lazy repeaters may provide incorrect results"</span>
        toks.shift()
        gens.push(generator.repeat(gens.pop(), <span class="hljs-number">0</span>, <span class="hljs-number">10</span>))
      <span class="hljs-keyword">else</span>
        gens.push(generator.repeat(gens.pop(), <span class="hljs-number">0</span>, <span class="hljs-number">100</span>))
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> token <span class="hljs-keyword">is</span> <span class="hljs-string">'?'</span>
      gens.push(generator.repeat(gens.pop(), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>))
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> token <span class="hljs-keyword">is</span> <span class="hljs-string">'+'</span>
      <span class="hljs-keyword">if</span> toks[<span class="hljs-number">0</span>] == <span class="hljs-string">'?'</span>
        <span class="hljs-built_in">console</span>.log <span class="hljs-string">"Lazy repeaters may provide incorrect results"</span>
        toks.shift()
        gens.push(generator.repeat(gens.pop(), <span class="hljs-number">1</span>, <span class="hljs-number">10</span>))
      <span class="hljs-keyword">else</span>
        gens.push(generator.repeat(gens.pop(), <span class="hljs-number">1</span>, <span class="hljs-number">100</span>))
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> token <span class="hljs-keyword">is</span> <span class="hljs-string">'|'</span>
      <span class="hljs-keyword">return</span> qc.oneOf(qc.string.concat(gens), generatorForPattern(toks))
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> token <span class="hljs-keyword">is</span> <span class="hljs-string">'['</span> <span class="hljs-comment"># Character class</span>
      charachters = []
      negative = <span class="hljs-literal">false</span>
      <span class="hljs-keyword">loop</span>
        char = toks.shift()
        <span class="hljs-keyword">if</span> char == <span class="hljs-string">']'</span>
          <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> char <span class="hljs-keyword">is</span> <span class="hljs-string">'^'</span>
          negative = <span class="hljs-literal">true</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> char <span class="hljs-keyword">is</span> <span class="hljs-string">'\\'</span>
          charachters = charachters.concat(handleClass(toks.shift()))
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> char <span class="hljs-keyword">is</span> <span class="hljs-string">'-'</span>
          charachters = charachters.concat(makeRange(charachters.pop(), toks.shift(), caseInsensitive))
        <span class="hljs-keyword">else</span>
          charachters.push(char)
      <span class="hljs-keyword">if</span> negative
        gens.push(qc.pick(makeComplimentaryRange(charachters)))
      <span class="hljs-keyword">else</span>
        gens.push(qc.pick(charachters))
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> token <span class="hljs-keyword">is</span> <span class="hljs-string">')'</span>
      <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> token <span class="hljs-keyword">is</span> <span class="hljs-string">'\\'</span>
      chars = handleClass(toks.shift(), captures, captureLevel)
      <span class="hljs-keyword">if</span> <span class="hljs-keyword">typeof</span> chars <span class="hljs-keyword">is</span> <span class="hljs-string">'function'</span>
        gens.push(chars)
      <span class="hljs-keyword">else</span>
        gens.push(qc.pick(chars))
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> token <span class="hljs-keyword">is</span> <span class="hljs-string">'{'</span>
      subtoken = toks.shift()
      str = <span class="hljs-string">''</span>
      <span class="hljs-keyword">until</span> subtoken == <span class="hljs-string">','</span> || subtoken == <span class="hljs-string">'}'</span>
        str += subtoken
        subtoken = toks.shift()
      from = parseInt(str, <span class="hljs-number">10</span>)
      <span class="hljs-keyword">if</span> subtoken == <span class="hljs-string">'}'</span>
        to = from
      <span class="hljs-keyword">else</span>
        str = <span class="hljs-string">''</span>
        subtoken = toks.shift()
        <span class="hljs-keyword">if</span> subtoken == <span class="hljs-string">'}'</span>
          to = <span class="hljs-number">100</span>
        <span class="hljs-keyword">else</span>
          <span class="hljs-keyword">until</span> subtoken == <span class="hljs-string">'}'</span>
            str += subtoken
            subtoken = toks.shift()
          to = parseInt(str, <span class="hljs-number">10</span>)
      gens.push(generator.repeat(gens.pop(), from, to))
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> token <span class="hljs-keyword">is</span> <span class="hljs-string">'('</span>
      <span class="hljs-keyword">if</span> toks[<span class="hljs-number">0</span>] == <span class="hljs-string">'?'</span> &amp;&amp; (toks[<span class="hljs-number">1</span>] == <span class="hljs-string">':'</span> || toks[<span class="hljs-number">1</span>] == <span class="hljs-string">'='</span>)
        toks.shift()
        toks.shift()
        gens.push(generatorForPattern(toks, caseInsensitive, captures, captureLevel))
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> toks[<span class="hljs-number">0</span>] == <span class="hljs-string">'?'</span> &amp;&amp; toks[<span class="hljs-number">1</span>] == <span class="hljs-string">'!'</span>
        toks.shift()
        toks.shift()
        <span class="hljs-keyword">throw</span> <span class="hljs-string">"Negative lookahead is not supported."</span>
      <span class="hljs-keyword">else</span>
        gens.push(capture(generatorForPattern(toks, caseInsensitive, captures, captureLevel + <span class="hljs-number">1</span>), captures, captureLevel))
    <span class="hljs-keyword">else</span>
      gens.push(<span class="hljs-function">-&gt;</span> token)
  qc.string.concat(gens)

qc.string.matching = <span class="hljs-function"><span class="hljs-params">(pattern)</span> -&gt;</span>
  toks = pattern.source.split(<span class="hljs-string">''</span>)
  captures = {}
  patternGenerator = capture(generatorForPattern(toks, pattern.ignoreCase, captures, <span class="hljs-number">1</span>), captures, <span class="hljs-number">0</span>)
  <span class="hljs-keyword">if</span> pattern.<span class="hljs-built_in">global</span> &amp;&amp; !captures.isHookedFromStart &amp;&amp; !captures.isHookedFromEnd
    generator.repeat(qc.oneOf(patternGenerator, qc.string), <span class="hljs-number">1</span>, <span class="hljs-number">10</span>)
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> !captures.isHookedFromStart &amp;&amp; !captures.isHookedFromEnd
    qc.string.concat([qc.string, patternGenerator, qc.string])
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> !captures.isHookedFromStart &amp;&amp; captures.isHookedFromEnd
    qc.string.concat([qc.string, patternGenerator])
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> captures.isHookedFromStart &amp;&amp; !captures.isHookedFromEnd
    qc.string.concat([patternGenerator, qc.string])
  <span class="hljs-keyword">else</span>
    patternGenerator</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <h3 id="misc-generators">Misc generators</h3>

            </div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>qc.date will generate a random date</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.date = <span class="hljs-function"><span class="hljs-params">(size)</span> -&gt;</span>
  y = qc.intUpto <span class="hljs-number">3000</span>
  m = qc.intUpto <span class="hljs-number">12</span>
  d = qc.intUpto <span class="hljs-keyword">if</span> m <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>] <span class="hljs-keyword">then</span> <span class="hljs-number">31</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> m <span class="hljs-keyword">in</span> [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>] <span class="hljs-keyword">then</span> <span class="hljs-number">30</span> <span class="hljs-keyword">else</span> <span class="hljs-number">28</span>
  hh = qc.intUpto <span class="hljs-number">24</span>
  mm = qc.intUpto <span class="hljs-number">60</span>
  ss = qc.intUpto <span class="hljs-number">60</span>
  ms = qc.intUpto <span class="hljs-number">1000</span>
  <span class="hljs-keyword">new</span> Date y, m, d, hh, mm, ss, ms</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>qc.any will generate a value of any type. For performance reasons there is a bias
towards simpler types with the following approx. distribution:</p>
<table>
<thead>
<tr>
<th>Probability</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>       4%</td>
<td><code>object</code></td>
</tr>
<tr>
<td>       8%</td>
<td><code>array</code></td>
</tr>
<tr>
<td>      13%</td>
<td><code>string</code></td>
</tr>
<tr>
<td>      14%</td>
<td><code>function</code></td>
</tr>
<tr>
<td>      16%</td>
<td><code>real</code></td>
</tr>
<tr>
<td>      20%</td>
<td><code>integer</code></td>
</tr>
<tr>
<td>      25%</td>
<td><code>boolean</code></td>
</tr>
</tbody>
</table>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.any = qc.oneOfByPriority qc.bool, qc.int, qc.real, (<span class="hljs-function">-&gt;</span><span class="hljs-function"> -&gt;</span>), (<span class="hljs-function">-&gt;</span> <span class="hljs-literal">undefined</span>), qc.string, qc.array, qc.object</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>qc.any.simple will only generate simple types, i.e. booleans, numbers, strings and null</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.any.simple = qc.oneOf qc.bool, qc.int, qc.real, qc.string, qc.pick(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">null</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>qc.any.datatype will only generate types that are data, not code, i.e. booleans, numbers, strings, null, arrays and objects</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.any.datatype = qc.oneOf qc.bool, qc.int, qc.real, qc.string, qc.pick(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">null</span>), qc.array, qc.object</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>Color is a utility for making web colors, i.e. will return a CSS compatible string (#fff).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.color = qc.string.matching(<span class="hljs-regexp">/^\#([A-F\d]{6}|[A-F\d]{3})$/i</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>Location calculates a random lat, long pair on the surface of the Earth.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.location = <span class="hljs-function"><span class="hljs-params">(size)</span> -&gt;</span>
<span class="hljs-function">  <span class="hljs-title">rad2deg</span> = <span class="hljs-params">(n)</span> -&gt;</span> <span class="hljs-number">360</span> * n / (<span class="hljs-number">2</span> * Math.PI)
  x = qc.random() * <span class="hljs-number">2</span> * Math.PI - Math.PI
  y = Math.PI / <span class="hljs-number">2</span> - Math.acos(qc.random() * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>)
  [rad2deg(y), rad2deg(x)]</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <h1 id="shrinking">Shrinking</h1>
<p>Shrinking is the secret sauce of quick_check.js. It allows examples to be reduced
to their minimal form.</p>
<p>After many iterations, this code is heavily inspired by Brian Donovanâ€™s shrinker.</p>

            </div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>This property sets globally whether to perform shrinking. While it is publicly
exposed, it is expected that integrations will expose a higher-level API over
merely setting this propert. Hence the underscore in its name.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc._performShrinks = <span class="hljs-literal">true</span></pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>We store global shrinkers in this private property. A shrinker is an object with
two functions: <code>valid</code> and <code>shrinker</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>registry = []</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>This part of the codebase heavily uses iterators and ES6 generator functions
(not to be confused with quick_check generators). Here we define an empty iterator
for returning in cases where we have no sensible data to return.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>emptyIterator =
  <span class="hljs-attribute">next</span>: <span class="hljs-function">-&gt;</span> <span class="hljs-attribute">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attribute">done</span>: <span class="hljs-literal">yes</span></pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>This is a method that creates a global shrinker for a particular kind of data.
It accepts two parameters, which are both functions: the first can be thought
of as a rule when the shrinker can apply to a particular value, the second
should be a generator function that actually returns smaller values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.addShrinker = <span class="hljs-function"><span class="hljs-params">(valid, shrinker)</span> -&gt;</span>
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">typeof</span> valid <span class="hljs-keyword">is</span> <span class="hljs-string">'string'</span>
<span class="hljs-function">    <span class="hljs-title">valid</span> = <span class="hljs-params">(val)</span> -&gt;</span> val.constructor.name == valid
  shrinker = {valid, shrinker}
  registry.push shrinker
  shrinker</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>Generates possible shrinks for the given data using the registry rules. As an
optimization, you can pass in a shrinker as a second argument, which allows
short-circuiting the detection routine of the normal call (though keep in mind
that this optimization can also change the result, since shrinking will use the
first shrinker whose <code>valid</code> rule is true, and there is no guarantee that <code>valid</code>
rules will be mutually exclusive).</p>
<p>Finally, you can pass in your own registry of shrinkers, in case you want to
bypass the builtins.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.shrink = <span class="hljs-function"><span class="hljs-params">(value, hint, shrinkers = registry)</span> -&gt;</span>
  <span class="hljs-keyword">if</span> hint?.valid?(value)
    <span class="hljs-keyword">return</span> hint.shrinker(value)
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">for</span> {valid, shrinker} <span class="hljs-keyword">in</span> shrinkers
      <span class="hljs-keyword">return</span> shrinker(value) <span class="hljs-keyword">if</span> valid(value)
  emptyIterator</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>The core idea of shrinking is a guided search through the possible smaller values
while maintaining a property (in this case that the <code>prop</code> returns <code>false</code>). We
also want to find an example quickly, so we limit the number of iterations.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-title">findMinimalExample</span> = <span class="hljs-params">(prop, examples, generators, limit = <span class="hljs-number">1000</span>)</span> -&gt;</span>
  iterations = <span class="hljs-number">0</span>
  last = examples
  <span class="hljs-keyword">while</span> iterations &lt; limit
    shrunk = <span class="hljs-literal">false</span>
    iterateGenArray last.map(<span class="hljs-function"><span class="hljs-params">(example)</span> -&gt;</span> qc.shrink(example)), <span class="hljs-function"><span class="hljs-params">(vals)</span> -&gt;</span>
      <span class="hljs-keyword">unless</span> prop(vals...)
        last = vals
        shrunk = <span class="hljs-literal">true</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
      <span class="hljs-literal">true</span>
    <span class="hljs-keyword">break</span> <span class="hljs-keyword">unless</span> shrunk
    iterations += <span class="hljs-number">1</span>
  <span class="hljs-keyword">return</span> <span class="hljs-attribute">shrinkCount</span>: iterations, <span class="hljs-attribute">examples</span>: last</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>In order to get a list of arguments for the property, we need to iterate through
possible ones. We get this in the form of a list of iterators, however, we need
to iterate by lists of values. A problem is that each generator may produce a
different number of elements. In that case we keep the last of these.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-title">iterateGenArray</span> = <span class="hljs-params">(arr, fn)</span> -&gt;</span>
  dones = (<span class="hljs-literal">false</span> <span class="hljs-keyword">for</span> gen <span class="hljs-keyword">in</span> arr)
  res = []
  atLeastOneValueAssigned = dones.slice()
  <span class="hljs-keyword">while</span> dones.some(<span class="hljs-function"><span class="hljs-params">(a)</span> -&gt;</span> !a)
    <span class="hljs-keyword">for</span> gen, i <span class="hljs-keyword">in</span> arr
      next = gen.next()
      dones[i] = next.done
      <span class="hljs-keyword">unless</span> next.done
        res[i] = next.value
        atLeastOneValueAssigned[i] = <span class="hljs-literal">true</span>
    stop = fn(res) <span class="hljs-keyword">if</span> atLeastOneValueAssigned.every(<span class="hljs-function"><span class="hljs-params">(a)</span> -&gt;</span> a)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> stop == <span class="hljs-literal">false</span></pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <h2 id="shrinkers">Shrinkers</h2>
<p>quick_check.js comes with several shrinkers built-in. Currently, the number is
quite rudimentary, but more will be added in future versions.</p>

            </div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <h3 id="shrinking-integers">Shrinking Integers</h3>
<p>If an integer is negative, first we try simplifying by turning it into a positive
number. If that doesnâ€™t work, we try using the stratgy for positive numbers and
then flip the sign.</p>
<p>For postive numbers we start with zero, and then increase the value exponentially
until we reach the original number.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>intShrinker = qc.addShrinker (val) -&gt;
  <span class="hljs-keyword">typeof</span> val <span class="hljs-keyword">is</span> <span class="hljs-string">'number'</span> <span class="hljs-keyword">and</span> Math.round(val) <span class="hljs-keyword">is</span> val
, <span class="hljs-function"><span class="hljs-params">(value)</span> -&gt;</span>
  <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">0</span>
    yield -value
    positives = qc.shrink(-value, intShrinker)
    <span class="hljs-keyword">until</span> (next = positives.next()).done
      yield -next.value
  <span class="hljs-keyword">else</span>
    diff = value
    <span class="hljs-keyword">while</span> diff &gt; <span class="hljs-number">0</span>
      yield value - diff
      diff = Math.floor(diff / <span class="hljs-number">2</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <h3 id="shrinking-floats">Shrinking Floats</h3>
<p>Floats work almost identically with integers, but there is no flooring involved.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>floatShrinker = qc.addShrinker (val) -&gt;
  <span class="hljs-keyword">typeof</span> val <span class="hljs-keyword">is</span> <span class="hljs-string">'number'</span> <span class="hljs-keyword">and</span> Math.round(val) <span class="hljs-keyword">isnt</span> val
, <span class="hljs-function"><span class="hljs-params">(value)</span> -&gt;</span>
  <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">0</span>
    yield -value
    positives = qc.shrink(-value, floatShrinker)
    next = <span class="hljs-literal">undefined</span>
    yield -next.value <span class="hljs-keyword">until</span> (next = positives.next()).done
  <span class="hljs-keyword">else</span>
    diff = value
    <span class="hljs-keyword">while</span> value - diff &lt; value
      yield value - diff
      diff = diff / <span class="hljs-number">2</span></pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <h3 id="shrinking-arrays">Shrinking Arrays</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.addShrinker (val) -&gt;
  <span class="hljs-attribute">Object</span>::toString.call(val) <span class="hljs-keyword">is</span> <span class="hljs-string">'[object Array]'</span>
, <span class="hljs-function"><span class="hljs-params">(value)</span> -&gt;</span></pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>The smallest array is the empty array, which we canâ€™t shrink further, but we
try the first, since if the test fails even on that, we have a very small
small example indeed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> value.length == <span class="hljs-number">0</span>
  yield []</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>Next we try to remove various slices of the array. We start by removing half
the array in order, slowly decreasing the number of elements to remove.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  toRemove = Math.floor(value.length / <span class="hljs-number">2</span>)
  <span class="hljs-keyword">while</span> toRemove &gt; <span class="hljs-number">0</span>
    offset = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> offset + toRemove &lt;= value.length
      yield value.slice(<span class="hljs-number">0</span>, offset).concat(value.slice(offset + toRemove));
      offset += <span class="hljs-number">1</span>
    toRemove = Math.floor(toRemove / <span class="hljs-number">2</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>Then we shrink the values contained in the array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">for</span> elem, i <span class="hljs-keyword">in</span> value
    smaller = qc.shrink(elem)
    <span class="hljs-keyword">until</span> (next = smaller.next()).done
      yield value.slice(<span class="hljs-number">0</span>, i).concat([next.value], value.slice(i + <span class="hljs-number">1</span>))</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <h3 id="shrinking-strings">Shrinking Strings</h3>
<p>Strings use a method very similar to arrays, but without the recursive bit.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>qc.addShrinker (val) -&gt;
  <span class="hljs-keyword">typeof</span> val <span class="hljs-keyword">is</span> <span class="hljs-string">'string'</span>
, <span class="hljs-function"><span class="hljs-params">(value)</span> -&gt;</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> value.length <span class="hljs-keyword">is</span> <span class="hljs-number">0</span>

  yield <span class="hljs-string">''</span>

  toRemove = Math.floor(value.length / <span class="hljs-number">2</span>)

  <span class="hljs-keyword">while</span> toRemove &gt; <span class="hljs-number">0</span>
    offset = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> offset + toRemove &lt;= value.length
      yield value.slice(<span class="hljs-number">0</span>, offset).concat(value.slice(offset + toRemove));
      offset += <span class="hljs-number">1</span>
    toRemove = Math.floor(toRemove / <span class="hljs-number">2</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <h1 id="jasmine-integration">Jasmine integration</h1>

            </div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>Integrating into Jasmine is very simple. Feel free to contribute adapters for
other testing toolkits.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">if</span> jasmine?
  beforeEach -&gt;
    jasmine.addMatchers
      <span class="hljs-attribute">forAll</span>: <span class="hljs-function">-&gt;</span>
        <span class="hljs-attribute">compare</span>: qc
        <span class="hljs-attribute">negativeCompare</span>: <span class="hljs-function"><span class="hljs-params">(prop, gens...)</span> -&gt;</span>
          orig = qc._performShrinks
          qc._performShrinks = <span class="hljs-literal">false</span>
          {pass, examples, message} = qc(prop, gens...)
          qc._performShrinks = orig
          {examples, message, <span class="hljs-attribute">pass</span>: !pass}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
